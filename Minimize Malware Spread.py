#Minimize Malware Spread
#https://leetcode.com/problems/minimize-malware-spread/
class Graph(object):
    def __init__(self):
        self.graphNodes = []
        self.totalGraphNodes = 0
        self.infectedNodes = []
        self.totalInfectedNodes = 0
        
class Solution(object):

    def getInfected(self, graphNodes, infectedNodes):
        return list(set(graphNodes) & set(infectedNodes))

    def dfs(self, node, graph, visited, g):
        visited[node] = 1
        g.graphNodes.append(node)
        for neighbor in range(len(graph)):
            if(visited[neighbor] == 0 and graph[node][neighbor] == 1):
                self.dfs(neighbor, graph, visited, g)

    #this function returns all indivudial disconnected graphs                
    def logic(self, graph, initial):
        visited = [0 for node in range(len(graph))]
        indivudialGraphs = []
        for node in range(len(graph)):
            if(visited[node] == 0):
                g = Graph()
                self.dfs(node, graph, visited, g)
                g.totalGraphNodes = len(g.graphNodes)
                g.infectedNodes = self.getInfected(g.graphNodes, initial)
                g.totalInfectedNodes = len(g.infectedNodes)
                #We dont care about the graph that doesn't have any infected nodes
                if(g.totalInfectedNodes > 0):
                    indivudialGraphs.append(g)
        return indivudialGraphs   
        
    def minMalwareSpread(self, graph, initial):
        indivudialGraphs = self.logic(graph, initial)
        #sort objects with respect to length of infectedNodes in  them.
        indivudialGraphs.sort(key=lambda x: (x.totalInfectedNodes), reverse=False)
        #select only those graphs with lowest number of infected nodes.
        #since the indivudial graph objects are already sorted according to lowest number of infected nodes
        #we know that first object will have the lowest number of infected nodes.
        lowestInfectedNodesInGraph = []
        for i in range(len(indivudialGraphs)):
            if(indivudialGraphs[0].totalInfectedNodes == indivudialGraphs[i].totalInfectedNodes):
                lowestInfectedNodesInGraph.append(indivudialGraphs[i])
        #here we need to save the graph with highest number of nodes
        lowestInfectedNodesInGraph.sort(key=lambda x: x.totalGraphNodes, reverse=True)
        highestGraphNodes = []
        #Select those graphs with highest number of graph nodes
        for i in range(len(lowestInfectedNodesInGraph)):
            if(lowestInfectedNodesInGraph[0].totalGraphNodes == lowestInfectedNodesInGraph[i].totalGraphNodes):
                highestGraphNodes.append(lowestInfectedNodesInGraph[i])
        #from these graphs just select node with lowest index
        infectedNodesIndices = []
        for g in highestGraphNodes:
            infectedNodesIndices = infectedNodesIndices + g.infectedNodes
        infectedNodesIndices.sort()
        return infectedNodesIndices[0]
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """

#Main
graph = [
    [1,1,0,1, 0,0,0,0],
    [1,1,0,0,1,0,0,0],
    [0,0,1,0,0,1,0,1],
    [1,0,0,1,0,0,1,0],
    [0,1,0,0,1,0,1,0],
    [0,0,1,0,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,1,0,0,1,0,1]
    ]
initial = [1,3,5]

graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1]

graph = [[1,0,0],[0,1,0],[0,0,1]]
initial = [0,2]

graph = [[1,1,1],[1,1,1],[1,1,1]]
initial = [1,2]

obj = Solution()
print obj.minMalwareSpread(graph, initial)
